                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       

********** à remplir obligatoirement **********

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: le vendredi 25 octobre 2024 à 19:00

Identité
--------
Nombre de binôme: **à remplir**
Nom, prénom 1: **à remplir**
Nom, prénom 2: **à remplir**


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

- La commande `make` s'éxecute sans erreurs ni warnings => tout compile correctement.
- La commande `make solve FILE=/examples/SAT/sudoku-4x4.cnf donne bien le résultat SAT 
  et l'interpretation correct associée.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Nous n'avons pas utilisé `filter_map`. 
Notre fonction simplifie itère à travers notre cnf et :
- supprime chaque clause disjonctive contenant le litteral `l` que l'on souhaite traité
- supprime chaque litteral `-l` de chaque clause disjonctive

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

**à remplir**

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Travaillant sur des ensembles (Set), nous avons utilisé les fonctions auxiliaires suivantes :
- LiteralSet.filter (afin de séparer les closes négatives des positives)
- LiteralSet.map abs (afin de rendre les négatives (déjà séparées) positive et rendre une comparaison entre les ensembles de clauses plus simple)
- LiteralSet.union (pour avoir l'ensemble des variables (sans - devant))
- LiteralSet.inter (pour connaître toutes les variables non pures)
- LiteralSet.diff (afin de séparer les variables pures de toutes les autres)
- flatten_clauses (afin de transformer une cnf en LiteralSet.t)

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

**à remplir**

---
5. Quelle a été votre méthodologie de test ?

Nous avons employé une méthodologie de tests unitaires de telle sorte à ce que lorsqu'un bug survient, un nouveau test est créer afin de s'assurer que ce bug precis ne se reproduise pas.
Dans le fichier dpll.mli nous avons explicité l'API publique ainsi qu'un module Test_expose rendant des fonctions publiques afin de permettre des tests unitaires séparés dans le dossier test.

---
6. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--